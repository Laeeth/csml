/* This file is a specification of the interface between the C# and
   the OCaml parts of the sample application. It must be processed by
   the csml compiler to produce a number of files. */


mlstub "getting_started_csml.ml"
/* The mlstub directive (which is mandatory) lets us choose the name
   of the OCaml "stub" file to be generated. This OCaml module will
   contain all the code needed to make OCaml values available to C#,
   as specified in this file. */

csstub "getting_started_csml.cs" CsmlGettingStarted
/* Similarly, the csstub directive lets us choose the name of a C#
   file that contains all the code needed to export C# values to
   OCaml. The identifier is the name of a class (to be generated in
   the namespace LexiFi.Interop). The C# part of the application
   should call the static method Init on this class so that C# values
   are made available to OCaml. */


csfile "getting_started_csml.cs"
/* A csfile directive (which can be repeated several times) introduces
   a part of C#-looking code that describes how to import values from
   OCaml. It produces a C# source file which imports these
   values. Here, we choose the same name as the C# stub file. */


/* csml lets us decide how values should be organized on the C#
   side. We can create classes in arbitrary namespaces and even create
   inner-classes. All the classes described here are implicitly
   declared "partial" in the code generated by the csml compiler. We
   can thus extend these classes with more definitions. */

namespace Getting {
  namespace Started {
    public static class Foo {
      public static class MyStaticClass {
        public static string DoSomething(string) = Getting_started.do_something;
        /* Here we declare a static method which wraps the OCaml
           function Getting_started.do_something. This function must
           have type string -> string (which is a translation of the
           C# signature above), otherwise we will get a compile-time
           type-error. */
      }
    }
  }
}


mlfile "getting_started_cs.ml"
/* The mlfile directive is the symmetric of csfile. Here we start a
   section where we will describe how to import components from C# and
   make them available to the OCaml code of our application. We must
   use a filename different from the stub code
   getting_started_csml.ml, because of OCaml compilation units cannot
   be mutually recursive (the stub code must export functions, and
   thus come "after" getting_started.ml, which itself will use
   functions defined here in getting_started_cs.ml). */

/* An mlfile section uses a syntax similar to OCaml's interfaces.  As
   for the C# parts, we can decide how to organize the code imported
   into OCaml within sub-modules of the compilation unit. */

module FooBar: sig
  val bipbip: int -> int -> unit = static Getting.Started.Foo.BipBip
  /* For each component to be imported from C#, we provide the expected OCaml type
     and a description of the C# component. Here we import a static method which takes
     two integers and returns nothing (void in C#). */
end
